##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: crypto-scripts-cm
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app.kubernetes.io/name: crypto-scripts
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
data:
  generate-crypto-orderer.sh: |-
    #!/bin/bash

    set -x

    CURRENT_DIR=${PWD}
    FULLY_QUALIFIED_ORG_NAME="{{ .Values.metadata.namespace }}"
    EXTERNAL_URL_SUFFIX="{{ .Values.org_data.external_url_suffix }}"
    ALTERNATIVE_ORG_NAMES=("{{ .Values.org_data.external_url_suffix }}")
    ORG_NAME="{{ .Values.metadata.org_name }}"
    SUBJECT="C={{ .Values.org_data.component_country }},ST={{ .Values.org_data.component_state }},L={{ .Values.org_data.component_location }},O={{ .Values.metadata.org_name }}"
    SUBJECT_PEER="{{ .Values.org_data.component_subject }}"
    CA="{{ .Values.org_data.ca_url }}"
    CA_ADMIN_USER="${ORG_NAME}-admin"
    CA_ADMIN_PASS="${ORG_NAME}-adminpw"
    
    ORG_ADMIN_USER="Admin@${FULLY_QUALIFIED_ORG_NAME}"
    ORG_ADMIN_PASS="Admin@${FULLY_QUALIFIED_ORG_NAME}-pw"

    ORG_CYPTO_FOLDER="/crypto-config/ordererOrganizations/${FULLY_QUALIFIED_ORG_NAME}"

    ROOT_TLS_CERT="/crypto-config/ordererOrganizations/${FULLY_QUALIFIED_ORG_NAME}/ca/ca.${FULLY_QUALIFIED_ORG_NAME}-cert.pem"

    CAS_FOLDER="${HOME}/ca-tools/cas/ca-${ORG_NAME}"
    ORG_HOME="${HOME}/ca-tools/${ORG_NAME}"

    ## Enroll CA administrator for Org. This user will be used to create other identities
    fabric-ca-client enroll -d -u https://${CA_ADMIN_USER}:${CA_ADMIN_PASS}@${CA} --tls.certfiles  ${ROOT_TLS_CERT} --home ${CAS_FOLDER} --csr.names "${SUBJECT_PEER}"

    ## Get the CA cert and store in Org MSP folder
    fabric-ca-client getcacert -d -u https://${CA} --tls.certfiles ${ROOT_TLS_CERT} -M ${ORG_CYPTO_FOLDER}/msp
    
    if [ "{{ .Values.metadata.proxy }}" != "none" ]; then
        mv ${ORG_CYPTO_FOLDER}/msp/cacerts/*.pem ${ORG_CYPTO_FOLDER}/msp/cacerts/ca-${FULLY_QUALIFIED_ORG_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem
    fi
    mkdir ${ORG_CYPTO_FOLDER}/msp/tlscacerts
    cp ${ORG_CYPTO_FOLDER}/msp/cacerts/* ${ORG_CYPTO_FOLDER}/msp/tlscacerts

    ## Register and enroll admin for Org and populate admincerts for MSP
    fabric-ca-client register -d --id.name ${ORG_ADMIN_USER} --id.secret ${ORG_ADMIN_PASS} --id.type admin --csr.names "${SUBJECT_PEER}" --id.attrs "hf.Registrar.Roles=client,hf.Registrar.Attributes=*,hf.Revoker=true,hf.AffiliationMgr=true,hf.GenCRL=true,admin=true:ecert,abac.init=true:ecert" --tls.certfiles ${ROOT_TLS_CERT} --home ${CAS_FOLDER}

    fabric-ca-client enroll -d -u https://${ORG_ADMIN_USER}:${ORG_ADMIN_PASS}@${CA} --tls.certfiles ${ROOT_TLS_CERT} --home ${ORG_HOME}/admin --csr.names "${SUBJECT_PEER}"

    mkdir -p ${ORG_CYPTO_FOLDER}/msp/admincerts
    cp ${ORG_HOME}/admin/msp/signcerts/* ${ORG_CYPTO_FOLDER}/msp/admincerts/${ORG_ADMIN_USER}-cert.pem

    mkdir ${ORG_HOME}/admin/msp/admincerts
    cp ${ORG_HOME}/admin/msp/signcerts/* ${ORG_HOME}/admin/msp/admincerts/${ORG_ADMIN_USER}-cert.pem

    mkdir -p ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}
    cp -R ${ORG_HOME}/admin/msp ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}

    if [ "{{ .Values.metadata.proxy }}" != "none" ]; then
        mv ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/msp/cacerts/*.pem ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/msp/cacerts/ca-${FULLY_QUALIFIED_ORG_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem
    fi

    # Get TLS cert for admin and copy to appropriate location
    fabric-ca-client enroll -d --enrollment.profile tls -u https://${ORG_ADMIN_USER}:${ORG_ADMIN_PASS}@${CA} -M ${ORG_HOME}/admin/tls --tls.certfiles ${ROOT_TLS_CERT}  --csr.names "${SUBJECT_PEER}"

    # Copy the TLS key and cert to the appropriate place
    mkdir -p ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/tls
    cp ${ORG_HOME}/admin/tls/keystore/* ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/tls/client.key
    cp ${ORG_HOME}/admin/tls/signcerts/* ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/tls/client.crt
    cp ${ORG_HOME}/admin/tls/tlscacerts/* ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/tls/ca.crt

    cd ${CURRENT_DIR}
  
  orderer-script.sh: |-
    #!/bin/bash

    set -x

    CURRENT_DIR=${PWD}
    FULLY_QUALIFIED_ORG_NAME="{{ .Values.metadata.namespace }}"
    EXTERNAL_URL_SUFFIX="{{ .Values.org_data.external_url_suffix }}"
    ALTERNATIVE_ORG_NAMES=("{{ .Values.org_data.external_url_suffix }}")
    ORG_NAME="{{ .Values.metadata.org_name }}"
    SUBJECT="C={{ .Values.org_data.component_country }},ST={{ .Values.org_data.component_state }},L={{ .Values.org_data.component_location }},O={{ .Values.metadata.org_name }}"
    SUBJECT_PEER="{{ .Values.org_data.component_subject }}"
    CA="{{ .Values.org_data.ca_url }}"
    CA_ADMIN_USER="${ORG_NAME}-admin"
    CA_ADMIN_PASS="${ORG_NAME}-adminpw"
    ORDERER_NAME=$1

    ORG_ADMIN_USER="Admin@${FULLY_QUALIFIED_ORG_NAME}"
    ORG_ADMIN_PASS="Admin@${FULLY_QUALIFIED_ORG_NAME}-pw"

    ORG_CYPTO_FOLDER="/crypto-config/ordererOrganizations/${FULLY_QUALIFIED_ORG_NAME}"

    ROOT_TLS_CERT="/crypto-config/ordererOrganizations/${FULLY_QUALIFIED_ORG_NAME}/ca/ca.${FULLY_QUALIFIED_ORG_NAME}-cert.pem"

    CAS_FOLDER="${HOME}/ca-tools/cas/ca-${ORG_NAME}"
    ORG_HOME="${HOME}/ca-tools/${ORG_NAME}"

    ## Register and enroll node and populate its MSP folder
    PEER="${ORDERER_NAME}.${FULLY_QUALIFIED_ORG_NAME}"
    CSR_HOSTS=${PEER}
    for i in "${ALTERNATIVE_ORG_NAMES[@]}"
    do
      CSR_HOSTS="${CSR_HOSTS},${ORDERER_NAME}.${i}"
    done
    echo "Registering and enrolling $PEER with csr hosts ${CSR_HOSTS}"

    # Register the peer
    fabric-ca-client register -d --id.name ${PEER} --id.secret ${PEER}-pw --id.type orderer --tls.certfiles ${ROOT_TLS_CERT} --home ${CAS_FOLDER}

    # Enroll to get peers TLS cert
    fabric-ca-client enroll -d --enrollment.profile tls -u https://${PEER}:${PEER}-pw@${CA} -M ${ORG_HOME}/cas/orderers/tls --csr.hosts "${CSR_HOSTS}" --tls.certfiles ${ROOT_TLS_CERT} --csr.names "${SUBJECT_PEER}"

    # Copy the TLS key and cert to the appropriate place
    mkdir -p ${ORG_CYPTO_FOLDER}/orderers/${PEER}/tls
    cp ${ORG_HOME}/cas/orderers/tls/keystore/* ${ORG_CYPTO_FOLDER}/orderers/${PEER}/tls/server.key
    cp ${ORG_HOME}/cas/orderers/tls/signcerts/* ${ORG_CYPTO_FOLDER}/orderers/${PEER}/tls/server.crt
    cp ${ORG_HOME}/cas/orderers/tls/tlscacerts/* ${ORG_CYPTO_FOLDER}/orderers/${PEER}/tls/ca.crt

    rm -rf ${ORG_HOME}/cas/orderers/tls
    
    # Enroll again to get the peer's enrollment certificate (default profile)
    fabric-ca-client enroll -d -u https://${PEER}:${PEER}-pw@${CA} -M ${ORG_CYPTO_FOLDER}/orderers/${PEER}/msp --tls.certfiles ${ROOT_TLS_CERT} --csr.names "${SUBJECT_PEER}"


    # Create the TLS CA directories of the MSP folder if they don't exist.
    mkdir ${ORG_CYPTO_FOLDER}/orderers/${PEER}/msp/tlscacerts

    if [ "{{ .Values.metadata.proxy }}" != "none" ]; then
      mv ${ORG_CYPTO_FOLDER}/orderers/${PEER}/msp/cacerts/*.pem ${ORG_CYPTO_FOLDER}/orderers/${PEER}/msp/cacerts/ca-${FULLY_QUALIFIED_ORG_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem
    fi
    cp ${ORG_CYPTO_FOLDER}/orderers/${PEER}/msp/cacerts/* ${ORG_CYPTO_FOLDER}/orderers/${PEER}/msp/tlscacerts

    # Copy the peer org's admin cert into target MSP directory
    mkdir -p ${ORG_CYPTO_FOLDER}/orderers/${PEER}/msp/admincerts

    cp ${ORG_CYPTO_FOLDER}/msp/admincerts/${ORG_ADMIN_USER}-cert.pem ${ORG_CYPTO_FOLDER}/orderers/${PEER}/msp/admincerts

    cd ${CURRENT_DIR}

  generate-crypto-peer.sh: |-
    #!/bin/bash

    set -x

    CURRENT_DIR=${PWD}
    FULLY_QUALIFIED_ORG_NAME="{{ .Values.metadata.namespace }}"
    ALTERNATIVE_ORG_NAMES=("{{ .Values.metadata.namespace }}.svc.cluster.local" "{{ .Values.metadata.org_name }}.net" "{{ .Values.metadata.namespace }}.{{ .Values.org_data.external_url_suffix }}")
    ORG_NAME="{{ .Values.metadata.org_name }}"
    EXTERNAL_URL_SUFFIX="{{ .Values.org_data.external_url_suffix }}"
    AFFILIATION="{{ .Values.metadata.org_name }}"
    SUBJECT="C={{ .Values.org_data.component_country }},ST={{ .Values.org_data.component_state }},L={{ .Values.org_data.component_location }},O={{ .Values.metadata.org_name }}"
    SUBJECT_PEER="{{ .Values.org_data.component_subject }}"
    CA="{{ .Values.org_data.ca_url }}"
    CA_ADMIN_USER="${ORG_NAME}-admin"
    CA_ADMIN_PASS="${ORG_NAME}-adminpw"

    ORG_ADMIN_USER="Admin@${FULLY_QUALIFIED_ORG_NAME}"
    ORG_ADMIN_PASS="Admin@${FULLY_QUALIFIED_ORG_NAME}-pw"

    ORG_CYPTO_FOLDER="/crypto-config/peerOrganizations/${FULLY_QUALIFIED_ORG_NAME}"

    ROOT_TLS_CERT="/crypto-config/peerOrganizations/${FULLY_QUALIFIED_ORG_NAME}/ca/ca.${FULLY_QUALIFIED_ORG_NAME}-cert.pem"

    CAS_FOLDER="${HOME}/ca-tools/cas/ca-${ORG_NAME}"
    ORG_HOME="${HOME}/ca-tools/${ORG_NAME}"

    NO_OF_PEERS={{ .Values.peer_count }}

    ## Enroll CA administrator for Org. This user will be used to create other identities
    fabric-ca-client enroll -d -u https://${CA_ADMIN_USER}:${CA_ADMIN_PASS}@${CA} --tls.certfiles  ${ROOT_TLS_CERT} --home ${CAS_FOLDER}  --csr.names "${SUBJECT_PEER}"

    ## Get the CA cert and store in Org MSP folder
    fabric-ca-client getcacert -d -u https://${CA} --tls.certfiles ${ROOT_TLS_CERT} -M ${ORG_CYPTO_FOLDER}/msp

    if [ "{{ .Values.metadata.proxy }}" != "none" ]; then
      mv ${ORG_CYPTO_FOLDER}/msp/cacerts/*.pem ${ORG_CYPTO_FOLDER}/msp/cacerts/ca-${FULLY_QUALIFIED_ORG_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem
    fi
    mkdir ${ORG_CYPTO_FOLDER}/msp/tlscacerts
    cp ${ORG_CYPTO_FOLDER}/msp/cacerts/* ${ORG_CYPTO_FOLDER}/msp/tlscacerts

    # Add affiliation for organisation
    fabric-ca-client affiliation add ${AFFILIATION} -u https://${CA_ADMIN_USER}:${CA_ADMIN_PASS}@${CA} --tls.certfiles ${ROOT_TLS_CERT} --home ${CAS_FOLDER}
    ## Register and enroll admin for Org and populate admincerts for MSP
    fabric-ca-client register -d --id.name ${ORG_ADMIN_USER} --id.secret ${ORG_ADMIN_PASS} --id.type admin --csr.names "${SUBJECT_PEER}" --id.affiliation ${AFFILIATION} --id.attrs "hf.Registrar.Roles=client,hf.Registrar.Attributes=*,hf.Revoker=true,hf.AffiliationMgr=true,hf.GenCRL=true,admin=true:ecert,abac.init=true:ecert" --tls.certfiles ${ROOT_TLS_CERT} --home ${CAS_FOLDER}

    fabric-ca-client enroll -d -u https://${ORG_ADMIN_USER}:${ORG_ADMIN_PASS}@${CA} --id.affiliation ${AFFILIATION} --tls.certfiles ${ROOT_TLS_CERT} --home ${ORG_HOME}/admin  --csr.names "${SUBJECT_PEER}"

    mkdir -p ${ORG_CYPTO_FOLDER}/msp/admincerts
    cp ${ORG_HOME}/admin/msp/signcerts/* ${ORG_CYPTO_FOLDER}/msp/admincerts/${ORG_ADMIN_USER}-cert.pem

    mkdir ${ORG_HOME}/admin/msp/admincerts
    cp ${ORG_HOME}/admin/msp/signcerts/* ${ORG_HOME}/admin/msp/admincerts/${ORG_ADMIN_USER}-cert.pem

    mkdir -p ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}
    cp -R ${ORG_HOME}/admin/msp ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}

    if [ "{{ .Values.metadata.proxy }}" != "none" ]; then
      mv ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/msp/cacerts/*.pem ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/msp/cacerts/ca-${FULLY_QUALIFIED_ORG_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem
    fi

    # Get TLS cert for admin and copy to appropriate location
    fabric-ca-client enroll -d --enrollment.profile tls -u https://${ORG_ADMIN_USER}:${ORG_ADMIN_PASS}@${CA} -M ${ORG_HOME}/admin/tls --tls.certfiles ${ROOT_TLS_CERT} --csr.names "${SUBJECT_PEER}"

    # Copy the TLS key and cert to the appropriate place
    mkdir -p ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/tls
    cp ${ORG_HOME}/admin/tls/keystore/* ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/tls/client.key
    cp ${ORG_HOME}/admin/tls/signcerts/* ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/tls/client.crt
    cp ${ORG_HOME}/admin/tls/tlscacerts/* ${ORG_CYPTO_FOLDER}/users/${ORG_ADMIN_USER}/tls/ca.crt

    ## Register and enroll peers and populate their MSP folder
    COUNTER=0
    while [  ${COUNTER} -lt ${NO_OF_PEERS} ]; do
      PEER="peer${COUNTER}.${FULLY_QUALIFIED_ORG_NAME}"
      CSR_HOSTS=${PEER}
      for i in "${ALTERNATIVE_ORG_NAMES[@]}"
      do
        CSR_HOSTS="${CSR_HOSTS},peer${COUNTER}.${i}"
      done
      echo "Registering and enrolling $PEER with csr hosts ${CSR_HOSTS}"
      
      # Register the peer
      fabric-ca-client register -d --id.name ${PEER} --id.secret ${PEER}-pw --id.type peer --tls.certfiles ${ROOT_TLS_CERT} --home ${CAS_FOLDER}

      # Enroll to get peers TLS cert
      fabric-ca-client enroll -d --enrollment.profile tls -u https://${PEER}:${PEER}-pw@${CA} -M ${ORG_HOME}/cas/peers/tls --csr.hosts "${CSR_HOSTS}" --tls.certfiles ${ROOT_TLS_CERT}  --csr.names "${SUBJECT_PEER}"

      # Copy the TLS key and cert to the appropriate place
      mkdir -p ${ORG_CYPTO_FOLDER}/peers/${PEER}/tls
      cp ${ORG_HOME}/cas/peers/tls/keystore/* ${ORG_CYPTO_FOLDER}/peers/${PEER}/tls/server.key
      cp ${ORG_HOME}/cas/peers/tls/signcerts/* ${ORG_CYPTO_FOLDER}/peers/${PEER}/tls/server.crt
      cp ${ORG_HOME}/cas/peers/tls/tlscacerts/* ${ORG_CYPTO_FOLDER}/peers/${PEER}/tls/ca.crt
      
      rm -rf ${ORG_HOME}/cas/peers/tls
      
      # Enroll again to get the peer's enrollment certificate (default profile)
      fabric-ca-client enroll -d -u https://${PEER}:${PEER}-pw@${CA} -M ${ORG_CYPTO_FOLDER}/peers/${PEER}/msp --tls.certfiles ${ROOT_TLS_CERT}  --csr.names "${SUBJECT_PEER}"

      # Create the TLS CA directories of the MSP folder if they don't exist.
      mkdir -p ${ORG_CYPTO_FOLDER}/peers/${PEER}/msp/tlscacerts	
      
      # Copy the peer org's admin cert into target MSP directory
      mkdir -p ${ORG_CYPTO_FOLDER}/peers/${PEER}/msp/admincerts
      if [ "{{ .Values.metadata.proxy }}" != "none" ]; then
        mv ${ORG_CYPTO_FOLDER}/peers/${PEER}/msp/cacerts/*.pem ${ORG_CYPTO_FOLDER}/peers/${PEER}/msp/cacerts/ca-${FULLY_QUALIFIED_ORG_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem
      fi
      cp ${ORG_CYPTO_FOLDER}/peers/${PEER}/msp/cacerts/* ${ORG_CYPTO_FOLDER}/peers/${PEER}/msp/tlscacerts
      cp ${ORG_CYPTO_FOLDER}/msp/admincerts/${ORG_ADMIN_USER}-cert.pem ${ORG_CYPTO_FOLDER}/peers/${PEER}/msp/admincerts
      
      let COUNTER=COUNTER+1
    done

    cd ${CURRENT_DIR}
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: orderer-script-store-vault
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app.kubernetes.io/name: orderer-script-vault
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
data:
  store-vault-orderer.sh: |-
    #!/bin/bash

    formatCertificate () {
      NOMBRE="${1##*/}"
      while IFS= read -r line
      do
        echo "$line\n"
      done < ${1} > ${2}/${NOMBRE}.txt
    }

    validateVaultResponse () {
      if echo ${2} | grep "errors"; then
        echo "ERROR: unable to retrieve ${1}: ${2}"
        exit 1
      fi
      if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
      then
        http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/${1})
        curl_response=$?
        if test "$http_code" != "200" ; then
            echo "Http response code from Vault - $http_code and curl_response - $curl_response"
            if test "$curl_response" != "0"; then
              echo "Error: curl command failed with error code - $curl_response"
              exit 1
            fi
        fi
      fi
    }

    echo "Puting secrets/certificates from Vault server"
    KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
    validateVaultResponse 'vault login token' "${VAULT_TOKEN}"

    if [ -e /certcheck/absent_msp.txt ]; then

      FORMAT_CERTIFICATE_PATH="/formatcertificate"
      mkdir -p ${FORMAT_CERTIFICATE_PATH}/tls
      mkdir -p ${FORMAT_CERTIFICATE_PATH}/msp

      ORG_CYPTO_FOLDER="/crypto-config/ordererOrganizations/${COMPONENT_NAME}/users/Admin@${COMPONENT_NAME}"

      # This commands put the certificates with correct format for the curl command
      formatCertificate "${ORG_CYPTO_FOLDER}/tls/ca.crt" "${FORMAT_CERTIFICATE_PATH}/tls"
      formatCertificate "${ORG_CYPTO_FOLDER}/tls/client.crt" "${FORMAT_CERTIFICATE_PATH}/tls"
      formatCertificate "${ORG_CYPTO_FOLDER}/tls/client.key" "${FORMAT_CERTIFICATE_PATH}/tls"

      CA_CRT=$(cat ${FORMAT_CERTIFICATE_PATH}/tls/ca.crt.txt)
      CLIENT_CRT=$(cat ${FORMAT_CERTIFICATE_PATH}/tls/client.crt.txt)
      CLIENT_KEY=$(cat ${FORMAT_CERTIFICATE_PATH}/tls/client.key.txt)
      
      echo "
        {
          \"data\": 
            {
              \"ca.crt\": \"${CA_CRT}\",
              \"client.crt\": \"${CLIENT_CRT}\",
              \"client.key\": \"${CLIENT_KEY}\"
            }  
        }" > payload.json
      
      # This command copy organization level tls certificates for orgs
      curl \
        -H "X-Vault-Token: ${VAULT_TOKEN}" \
        -H "Content-Type: application/json" \
        -X POST \
        -d @payload.json \
        ${VAULT_ADDR}/v1/${VAULT_SECRET_TLS}
      
      # Check tls certificates
      response_status=$(curl -s -o /dev/null -w "%{http_code}" \
      --header "X-Vault-Token: ${VAULT_TOKEN}" \
      ${VAULT_ADDR}/v1/${VAULT_SECRET_TLS});

      validateVaultResponse 'tls cert check' ${response_status};
      
      rm payload.json

      # This commands put the certificates with correct format for the curl command
      SK_NAME=$(find ${ORG_CYPTO_FOLDER}/msp/keystore/ -name "*_sk")

      formatCertificate "${ORG_CYPTO_FOLDER}/msp/admincerts/Admin@${COMPONENT_NAME}-cert.pem" "${FORMAT_CERTIFICATE_PATH}/msp"
      formatCertificate "${SK_NAME}" "${FORMAT_CERTIFICATE_PATH}/msp"
      formatCertificate "${ORG_CYPTO_FOLDER}/msp/signcerts/cert.pem" "${FORMAT_CERTIFICATE_PATH}/msp"

      ADMINCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/Admin@${COMPONENT_NAME}-cert.pem.txt)
      KEYSTORE=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/*_sk.txt)
      SIGNCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/cert.pem.txt)

      if [ "$PROXY" != "none" ] ; then

        formatCertificate "${ORG_CYPTO_FOLDER}/msp/cacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem" "${FORMAT_CERTIFICATE_PATH}/msp"
        CACERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem.txt)
        
          echo "
            {
              \"data\": 
                {
                  \"admincerts\": \"${ADMINCERTS}\",
                  \"cacerts\": \"${CACERTS}\",
                  \"keystore\": \"${KEYSTORE}\",
                  \"signcerts\": \"${SIGNCERTS}\",
                  \"tlscacerts\": \"${CA_CRT}\"
                }  
            }" > payload.json
      fi;

      if [ "$PROXY" = "none" ] ; then

          formatCertificate "${ORG_CYPTO_FOLDER}/msp/cacerts/ca-${COMPONENT_NAME}-7054.pem" "${FORMAT_CERTIFICATE_PATH}/msp"
          CACERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/ca-${COMPONENT_NAME}-7054.pem.txt)

          echo "
            {
              \"data\": 
                {
                  \"admincerts\": \"${ADMINCERTS}\",
                  \"cacerts\": \"${CACERTS}\",
                  \"keystore\": \"${KEYSTORE}\",
                  \"signcerts\": \"${SIGNCERTS}\",
                  \"tlscacerts\": \"${CA_CRT}\"
                }  
            }" > payload.json
      fi;

      # This command copy organization level msp certificates for orgs
      curl \
        -H "X-Vault-Token: ${VAULT_TOKEN}" \
        -H "Content-Type: application/json" \
        -X POST \
        -d @payload.json \
        ${VAULT_ADDR}/v1/${VAULT_SECRET_MSP}
      
      # Check msp certificates
      response_status=$(curl -s -o /dev/null -w "%{http_code}" \
      --header "X-Vault-Token: ${VAULT_TOKEN}" \
      ${VAULT_ADDR}/v1/${VAULT_SECRET_MSP});

      validateVaultResponse 'msp cert check' ${response_status};

      rm payload.json

    fi;

    ORG_CYPTO_ORDERER_FOLDER="/crypto-config/ordererOrganizations/${COMPONENT_NAME}/orderers"
    
    list=$(echo "$ORDERERS_NAMES" | tr "-" "\n")         
    for ORDERER_NAME in $list
    do
      if [ -e /certcheck/absent_msp_${ORDERER_NAME}.txt ]; then

        # This commands put the certificates with correct format for the curl command
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/tls
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/cacerts
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/tlscacerts

        formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/tls/ca.crt" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/tls"
        formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/tls/server.crt" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/tls"
        formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/tls/server.key" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/tls"

        CA_CRT=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/tls/ca.crt.txt)
        SERVER_CRT=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/tls/server.crt.txt)
        SERVER_KEY=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/tls/server.key.txt)

        echo "
        {
          \"data\": 
            {
              \"ca.crt\": \"${CA_CRT}\",
              \"server.crt\": \"${SERVER_CRT}\",
              \"server.key\": \"${SERVER_KEY}\"
            }  
        }" > payload.json

        # This command copy the crypto material for orderer (tls)
        curl \
          -H "X-Vault-Token: ${VAULT_TOKEN}" \
          -H "Content-Type: application/json" \
          -X POST \
          -d @payload.json \
          ${VAULT_ADDR}/v1/${VAULT_SECRET_ORDERER}/${ORDERER_NAME}.${COMPONENT_NAME}/tls
        
        # Check tls certificates
        response_status=$(curl -s -o /dev/null -w "%{http_code}" \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/${VAULT_SECRET_ORDERER}/${ORDERER_NAME}.${COMPONENT_NAME}/tls);

        validateVaultResponse 'tls cert check' ${response_status};

        rm payload.json
        
        # This commands put the certificates with correct format for the curl command
        SK_NAME=$(find ${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/keystore/ -name "*_sk")

        formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/admincerts/Admin@${COMPONENT_NAME}-cert.pem" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp"
        formatCertificate "${SK_NAME}" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp"
        formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/signcerts/cert.pem" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp"

        ADMINCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/Admin@${COMPONENT_NAME}-cert.pem.txt)
        KEYSTORE=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/*_sk.txt)
        SIGNCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/cert.pem.txt)

        if [ "$PROXY" != "none" ] ; then

          formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/cacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/cacerts"
          formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/tlscacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/tlscacerts"
          CACERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/cacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem.txt)
          TLSCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/tlscacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem.txt)

          echo "
            {
              \"data\": 
                {
                  \"admincerts\": \"${ADMINCERTS}\",
                  \"cacerts\": \"${CACERTS}\",
                  \"keystore\": \"${KEYSTORE}\",
                  \"signcerts\": \"${SIGNCERTS}\",
                  \"tlscacerts\": \"${TLSCERTS}\"
                }  
            }" > payload.json

        fi;

        if [ "$PROXY" = "none" ] ; then
          formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/cacerts/ca-${COMPONENT_NAME}-7054.pem" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/cacerts"
          formatCertificate "${ORG_CYPTO_ORDERER_FOLDER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp/tlscacerts/ca-${COMPONENT_NAME}-7054.pem" "${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/tlscacerts"
          CACERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/cacerts/ca-${COMPONENT_NAME}-7054.pem.txt)
          TLSCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${ORDERER_NAME}/msp/tlscacerts/ca-${COMPONENT_NAME}-7054.pem.txt)

          echo "
            {
              \"data\": 
                {
                  \"admincerts\": \"${ADMINCERTS}\",
                  \"cacerts\": \"${CACERTS}\",
                  \"keystore\": \"${KEYSTORE}\",
                  \"signcerts\": \"${SIGNCERTS}\",
                  \"tlscacerts\": \"${TLSCERTS}\"
                }  
            }" > payload.json

        fi;

        # This command copy the msp certificates to the Vault
        curl \
          -H "X-Vault-Token: ${VAULT_TOKEN}" \
          -H "Content-Type: application/json" \
          -X POST \
          -d @payload.json \
          ${VAULT_ADDR}/v1/${VAULT_SECRET_ORDERER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp

        # Check msp certificates
        response_status=$(curl -s -o /dev/null -w "%{http_code}" \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
          ${VAULT_ADDR}/v1/${VAULT_SECRET_ORDERER}/${ORDERER_NAME}.${COMPONENT_NAME}/msp);

        validateVaultResponse 'msp cert check' ${response_status};

        rm payload.json
      fi;

      if [ "$PROXY" = "ambassador" ]; then

        AMBASSADOR_PATH="/crypto-config/${COMPONENT_TYPE}Organizations/${COMPONENT_NAME}"
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/ambassador

        if [ -e  ${MOUNT_PATH}/absent_ambassador_${ORDERER_NAME}.txt ]; then

          formatCertificate "${AMBASSADOR_PATH}/${ORDERER_NAME}-${COMPONENT_NAME}-certchain.pem" "${FORMAT_CERTIFICATE_PATH}/ambassador"
          formatCertificate "${AMBASSADOR_PATH}/${ORDERER_NAME}-${COMPONENT_NAME}.key" "${FORMAT_CERTIFICATE_PATH}/ambassador"
          CERTIFICATE=$(cat ${FORMAT_CERTIFICATE_PATH}/ambassador/${ORDERER_NAME}-${COMPONENT_NAME}-certchain.pem.txt)
          KEY=$(cat ${FORMAT_CERTIFICATE_PATH}/ambassador/${ORDERER_NAME}-${COMPONENT_NAME}.key.txt)

          echo "
              {
                \"data\": 
                  {
                    \"certificate\": \"${CERTIFICATE}\",
                    \"key\": \"${KEY}\"
                  }  
              }" > payload.json

          # This command copy the ambassador certificates to the Vault
            curl \
              -H "X-Vault-Token: ${VAULT_TOKEN}" \
              -H "Content-Type: application/json" \
              -X POST \
              -d @payload.json \
              ${VAULT_ADDR}/v1/${VAULT_SECRET_AMBASSADOR}/${ORDERER_NAME}

          # Check ambassador certificates
          response_status=$(curl -s -o /dev/null -w "%{http_code}" \
          --header "X-Vault-Token: ${VAULT_TOKEN}" \
          ${VAULT_ADDR}/v1/${VAULT_SECRET_AMBASSADOR}/${ORDERER_NAME});

          validateVaultResponse 'orderer cert check' ${response_status};

          rm payload.json
        fi;
      fi;
    done
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: peer-script-store-vault
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app.kubernetes.io/name: peer-script-vault
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
data:
  store-vault-peer.sh: |-
    #!/bin/bash

    formatCertificate () {
      NOMBRE="${1##*/}"
      while IFS= read -r line
      do
        echo "$line\n"
      done < ${1} > ${2}/${NOMBRE}.txt
    }

    validateVaultResponse () {
      if echo ${2} | grep "errors"; then
        echo "ERROR: unable to retrieve ${1}: ${2}"
        exit 1
      fi
      if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
      then
        http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/${1})
        curl_response=$?
        if test "$http_code" != "200" ; then
            echo "Http response code from Vault - $http_code and curl_response - $curl_response"
            if test "$curl_response" != "0"; then
              echo "Error: curl command failed with error code - $curl_response"
              exit 1
            fi
        fi
      fi
    }

    echo "Puting secrets/certificates from Vault server"
    KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    VAULT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login -H "Content-Type: application/json" -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | jq -r 'if .errors then . else .auth.client_token end')
    validateVaultResponse 'vault login token' "${VAULT_TOKEN}"
    
    FORMAT_CERTIFICATE_PATH="/formatcertificate"
    mkdir -p ${FORMAT_CERTIFICATE_PATH}/tls
    mkdir -p ${FORMAT_CERTIFICATE_PATH}/msp

    if [ -e /certcheck/absent_msp.txt ] || [ "$REFRESH_CERTS" == 'true' ]; then

      ORG_CYPTO_FOLDER="/crypto-config/peerOrganizations/${COMPONENT_NAME}/users/Admin@${COMPONENT_NAME}"

      # This commands put the certificates with correct format for the curl command
      formatCertificate "${ORG_CYPTO_FOLDER}/tls/ca.crt" "${FORMAT_CERTIFICATE_PATH}/tls"
      formatCertificate "${ORG_CYPTO_FOLDER}/tls/client.crt" "${FORMAT_CERTIFICATE_PATH}/tls"
      formatCertificate "${ORG_CYPTO_FOLDER}/tls/client.key" "${FORMAT_CERTIFICATE_PATH}/tls"

      CA_CRT=$(cat ${FORMAT_CERTIFICATE_PATH}/tls/ca.crt.txt)
      CLIENT_CRT=$(cat ${FORMAT_CERTIFICATE_PATH}/tls/client.crt.txt)
      CLIENT_KEY=$(cat ${FORMAT_CERTIFICATE_PATH}/tls/client.key.txt)
      
      echo "
        {
          \"data\": 
            {
              \"ca.crt\": \"${CA_CRT}\",
              \"client.crt\": \"${CLIENT_CRT}\",
              \"client.key\": \"${CLIENT_KEY}\"
            }  
        }" > payload.json
      
      # This command copy organization level tls certificates for orgs
      curl \
        -H "X-Vault-Token: ${VAULT_TOKEN}" \
        -H "Content-Type: application/json" \
        -X POST \
        -d @payload.json \
        ${VAULT_ADDR}/v1/${VAULT_SECRET_TLS}
      
      # Check tls certificates
      response_status=$(curl -s -o /dev/null -w "%{http_code}" \
      --header "X-Vault-Token: ${VAULT_TOKEN}" \
      ${VAULT_ADDR}/v1/${VAULT_SECRET_TLS});

      validateVaultResponse 'tls cert check' ${response_status};
      
      rm payload.json

      # This commands put the certificates with correct format for the curl command
      SK_NAME=$(find ${ORG_CYPTO_FOLDER}/msp/keystore/ -name "*_sk")

      formatCertificate "${ORG_CYPTO_FOLDER}/msp/admincerts/Admin@${COMPONENT_NAME}-cert.pem" "${FORMAT_CERTIFICATE_PATH}/msp"
      formatCertificate "${SK_NAME}" "${FORMAT_CERTIFICATE_PATH}/msp"
      formatCertificate "${ORG_CYPTO_FOLDER}/msp/signcerts/cert.pem" "${FORMAT_CERTIFICATE_PATH}/msp"

      ADMINCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/Admin@${COMPONENT_NAME}-cert.pem.txt)
      KEYSTORE=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/*_sk.txt)
      SIGNCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/cert.pem.txt)

      if [ "$PROXY" != "none" ] ; then

        formatCertificate "${ORG_CYPTO_FOLDER}/msp/cacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem" "${FORMAT_CERTIFICATE_PATH}/msp"
        CACERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem.txt)
        
          echo "
            {
              \"data\": 
                {
                  \"admincerts\": \"${ADMINCERTS}\",
                  \"cacerts\": \"${CACERTS}\",
                  \"keystore\": \"${KEYSTORE}\",
                  \"signcerts\": \"${SIGNCERTS}\",
                  \"tlscacerts\": \"${CA_CRT}\"
                }  
            }" > payload.json

      fi;

      if [ "$PROXY" = "none" ] ; then

          formatCertificate "${ORG_CYPTO_FOLDER}/msp/cacerts/ca-${COMPONENT_NAME}-7054.pem" "${FORMAT_CERTIFICATE_PATH}/msp"
          CACERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/msp/ca-${COMPONENT_NAME}-7054.pem.txt)

          echo "
            {
              \"data\": 
                {
                  \"admincerts\": \"${ADMINCERTS}\",
                  \"cacerts\": \"${CACERTS}\",
                  \"keystore\": \"${KEYSTORE}\",
                  \"signcerts\": \"${SIGNCERTS}\",
                  \"tlscacerts\": \"${CA_CRT}\"
                }  
            }" > payload.json
      fi;

      # This command copy organization level msp certificates for orgs
      curl \
        -H "X-Vault-Token: ${VAULT_TOKEN}" \
        -H "Content-Type: application/json" \
        -X POST \
        -d @payload.json \
        ${VAULT_ADDR}/v1/${VAULT_SECRET_MSP}
      
      # Check msp certificates
      response_status=$(curl -s -o /dev/null -w "%{http_code}" \
      --header "X-Vault-Token: ${VAULT_TOKEN}" \
      ${VAULT_ADDR}/v1/${VAULT_SECRET_MSP});

      validateVaultResponse 'msp cert check' ${response_status};

      rm payload.json
    fi;

    ORG_CYPTO_PEER_FOLDER="/crypto-config/peerOrganizations/${COMPONENT_NAME}/peers"

    list=$(echo "$PEERS_NAMES" | tr "-" "\n")         
    for PEER in $list
    do
      SAVE=false
      STATUS="${PEER##*,}"
      if [ "$STATUS" = "new" ] || [ "$STATUS" = "" ]; then
        PEER_NAME="${PEER%%,*}"
        SAVE=true
      fi;
      
      if [ -e /certcheck/absent_msp_${PEER_NAME}.txt ] && [ "$SAVE" == 'true' ]; then

        # This commands put the certificates with correct format for the curl command
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/tls
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/cacerts
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/tlscacerts

        formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/tls/ca.crt" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/tls"
        formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/tls/server.crt" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/tls"
        formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/tls/server.key" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/tls"

        CA_CRT=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/tls/ca.crt.txt)
        SERVER_CRT=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/tls/server.crt.txt)
        SERVER_KEY=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/tls/server.key.txt)

        echo "
        {
          \"data\": 
            {
              \"ca.crt\": \"${CA_CRT}\",
              \"server.crt\": \"${SERVER_CRT}\",
              \"server.key\": \"${SERVER_KEY}\"
            }  
        }" > payload.json

        # This command copy the crypto material for peers (tls)
        curl \
          -H "X-Vault-Token: ${VAULT_TOKEN}" \
          -H "Content-Type: application/json" \
          -X POST \
          -d @payload.json \
          ${VAULT_ADDR}/v1/${VAULT_SECRET_PEER}/${PEER_NAME}.${COMPONENT_NAME}/tls
        
        # Check tls certificates
        response_status=$(curl -s -o /dev/null -w "%{http_code}" \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/${VAULT_SECRET_PEER}/${PEER_NAME}.${COMPONENT_NAME}/tls);

        validateVaultResponse 'tls cert check' ${response_status};

        rm payload.json
        
        # This commands put the certificates with correct format for the curl command
        SK_NAME=$(find ${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/msp/keystore/ -name "*_sk")

        formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/msp/admincerts/Admin@${COMPONENT_NAME}-cert.pem" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp"
        formatCertificate "${SK_NAME}" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp"
        formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/msp/signcerts/cert.pem" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp"

        ADMINCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/Admin@${COMPONENT_NAME}-cert.pem.txt)
        KEYSTORE=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/*_sk.txt)
        SIGNCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/cert.pem.txt)

        if [ "$PROXY" != "none" ] ; then

          formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/msp/cacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/cacerts"
          formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/msp/tlscacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/tlscacerts"
          CACERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/cacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem.txt)
          TLSCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/tlscacerts/ca-${COMPONENT_NAME}-${EXTERNAL_URL_SUFFIX}-8443.pem.txt)

          echo "
            {
              \"data\": 
                {
                  \"admincerts\": \"${ADMINCERTS}\",
                  \"cacerts\": \"${CACERTS}\",
                  \"keystore\": \"${KEYSTORE}\",
                  \"signcerts\": \"${SIGNCERTS}\",
                  \"tlscacerts\": \"${TLSCERTS}\"
                }  
            }" > payload.json

        fi;

        if [ "$PROXY" = "none" ] ; then
          formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/msp/cacerts/ca-${COMPONENT_NAME}-7054.pem" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/cacerts"
          formatCertificate "${ORG_CYPTO_PEER_FOLDER}/${PEER_NAME}.${COMPONENT_NAME}/msp/tlscacerts/ca-${COMPONENT_NAME}-7054.pem" "${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/tlscacerts"
          CACERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/cacerts/ca-${COMPONENT_NAME}-7054.pem.txt)
          TLSCERTS=$(cat ${FORMAT_CERTIFICATE_PATH}/${PEER_NAME}/msp/tlscacerts/ca-${COMPONENT_NAME}-7054.pem.txt)

          echo "
            {
              \"data\": 
                {
                  \"admincerts\": \"${ADMINCERTS}\",
                  \"cacerts\": \"${CACERTS}\",
                  \"keystore\": \"${KEYSTORE}\",
                  \"signcerts\": \"${SIGNCERTS}\",
                  \"tlscacerts\": \"${TLSCERTS}\"
                }  
            }" > payload.json

        fi;

        # This command copy the msp certificates to the Vault
        curl \
          -H "X-Vault-Token: ${VAULT_TOKEN}" \
          -H "Content-Type: application/json" \
          -X POST \
          -d @payload.json \
          ${VAULT_ADDR}/v1/${VAULT_SECRET_PEER}/${PEER_NAME}.${COMPONENT_NAME}/msp

        # Check msp certificates
        response_status=$(curl -s -o /dev/null -w "%{http_code}" \
        --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/${VAULT_SECRET_PEER}/${PEER_NAME}.${COMPONENT_NAME}/msp);

        validateVaultResponse 'msp cert check' ${response_status};

        rm payload.json
      fi;

      if [ "$PROXY" = "ambassador" ]; then

        AMBASSADOR_PATH="/crypto-config/${COMPONENT_TYPE}Organizations/${COMPONENT_NAME}"
        mkdir -p ${FORMAT_CERTIFICATE_PATH}/ambassador
          
        if [ -e  ${MOUNT_PATH}/absent_ambassador_${PEER_NAME}.txt ] && [ "$SAVE" == 'true' ]; then

          formatCertificate "${AMBASSADOR_PATH}/${PEER_NAME}-${COMPONENT_NAME}-certchain.pem" "${FORMAT_CERTIFICATE_PATH}/ambassador"
          formatCertificate "${AMBASSADOR_PATH}/${PEER_NAME}-${COMPONENT_NAME}.key" "${FORMAT_CERTIFICATE_PATH}/ambassador"
          formatCertificate "${AMBASSADOR_PATH}/${PEER_NAME}-${COMPONENT_NAME}.pem" "${FORMAT_CERTIFICATE_PATH}/ambassador"

          CERTIFICATE=$(cat ${FORMAT_CERTIFICATE_PATH}/ambassador/${PEER_NAME}-${COMPONENT_NAME}-certchain.pem.txt)
          KEY=$(cat ${FORMAT_CERTIFICATE_PATH}/ambassador/${PEER_NAME}-${COMPONENT_NAME}.key.txt)
          CLIENTCERT=$(cat ${FORMAT_CERTIFICATE_PATH}/ambassador/${PEER_NAME}-${COMPONENT_NAME}.pem.txt)
      
          echo "
              {
                \"data\": 
                  {
                    \"clientcert\": \"${CLIENTCERT}\",
                    \"certificate\": \"${CERTIFICATE}\",
                    \"key\": \"${KEY}\"
                  }  
              }" > payload.json

          # This command copy the ambassador certificates generated above, to the Vault
            curl \
              -H "X-Vault-Token: ${VAULT_TOKEN}" \
              -H "Content-Type: application/json" \
              -X POST \
              -d @payload.json \
              ${VAULT_ADDR}/v1/${VAULT_SECRET_AMBASSADOR}

          # Check ambassador certificates
          response_status=$(curl -s -o /dev/null -w "%{http_code}" \
          --header "X-Vault-Token: ${VAULT_TOKEN}" \
          ${VAULT_ADDR}/v1/${VAULT_SECRET_AMBASSADOR});

          validateVaultResponse 'peer cert check' ${response_status};

          rm payload.json
        fi;
      fi;
    done

    if [ -e /certcheck/absent_config_file.txt ]; then

      # This commands put the config file with correct format for the curl command
      mkdir -p ${FORMAT_CERTIFICATE_PATH}/msp_config_file
      formatCertificate "/crypto-config/peerOrganizations/${COMPONENT_NAME}/msp/config.yaml" "${FORMAT_CERTIFICATE_PATH}/msp_config_file"
      MSP_CONFIG_FILE=$(cat ${FORMAT_CERTIFICATE_PATH}/msp_config_file/config.yaml.txt)

      echo "
          {
            \"data\": 
              {
                \"configfile\": \"${MSP_CONFIG_FILE}\"
              }  
          }" > payload.json
      
      # This command write the msp config file to Vault
      curl \
        -H "X-Vault-Token: ${VAULT_TOKEN}" \
        -H "Content-Type: application/json" \
        -X POST \
        -d @payload.json \
        ${VAULT_ADDR}/v1/${VAULT_SECRET_CONFIG_FILE}

      # Check msp config file 
      response_status=$(curl -s -o /dev/null -w "%{http_code}" \
      --header "X-Vault-Token: ${VAULT_TOKEN}" \
      ${VAULT_ADDR}/v1/${VAULT_SECRET_CONFIG_FILE});

      validateVaultResponse 'config file check' ${response_status};

    fi;
 
    if [ -e /certcheck/absent_orderer_tls_cert.txt ]; then
      list=$(echo "$ORDERERS_NAMES" | tr "-" "\n")         
      for ORDERER in $list
      do
        ORDERER_TLS=$(cat /tlscerts/${ORDERER}.crt)

        echo "
          {
            \"data\": 
              {
                \"ca.crt\": ${ORDERER_TLS}
              }  
          }" > payload.json

          # This command writes organization level certificates for orderers to vault
          curl \
            -H "X-Vault-Token: ${VAULT_TOKEN}" \
            -H "Content-Type: application/json" \
            -X POST \
            -d @payload.json \
            ${VAULT_ADDR}/v1/${VAULT_SECRET_PEER_ORDERER_TLS}
          
          # Check orderer certs
          response_status=$(curl -s -o /dev/null -w "%{http_code}" \
          --header "X-Vault-Token: ${VAULT_TOKEN}" \
          ${VAULT_ADDR}/v1/${VAULT_SECRET_PEER_ORDERER_TLS});

          validateVaultResponse 'organization level certificates check' ${response_status};
      done
    fi;

    # This command writes the couchdb credentials for each organization to the vault
    curl \
      -H "X-Vault-Token: ${VAULT_TOKEN}" \
      -H "Content-Type: application/json" \
      -X POST \
      -d '{ "data": {"user":"admin123"}}' \
      ${VAULT_ADDR}/v1/${VAULT_SECRET_COUCHDB}

      # Check couchdb credentials
      response_status=$(curl -s -o /dev/null -w "%{http_code}" \
      --header "X-Vault-Token: ${VAULT_TOKEN}" \
      ${VAULT_ADDR}/v1/${VAULT_SECRET_COUCHDB});

      validateVaultResponse 'couchdb credentials check' ${response_status};
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: msp-config-file
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app.kubernetes.io/name: msp-config-file
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
data:
  no-none-config.yaml: |-
    NodeOUs:
      Enable: true
      ClientOUIdentifier:
        Certificate: cacerts/ca-{{ .Values.metadata.namespace }}-{{ .Values.org_data.external_url_suffix }}-8443.pem
        OrganizationalUnitIdentifier: client
      PeerOUIdentifier:
        Certificate: cacerts/ca-{{ .Values.metadata.namespace }}-{{ .Values.org_data.external_url_suffix }}-8443.pem
        OrganizationalUnitIdentifier: peer
      AdminOUIdentifier:
          Certificate: cacerts/ca-{{ .Values.metadata.namespace }}-{{ .Values.org_data.external_url_suffix }}-8443.pem
          OrganizationalUnitIdentifier: admin
      OrdererOUIdentifier:
        Certificate: cacerts/ca-{{ .Values.metadata.namespace }}-{{ .Values.org_data.external_url_suffix }}-8443.pem
        OrganizationalUnitIdentifier: orderer
  none-config.yaml: |-
    NodeOUs:
      Enable: true
      ClientOUIdentifier:
        Certificate: cacerts/ca-{{ .Values.metadata.namespace }}-7054.pem
        OrganizationalUnitIdentifier: client
      PeerOUIdentifier:
        Certificate: cacerts/ca-{{ .Values.metadata.namespace }}-7054.pem
        OrganizationalUnitIdentifier: peer
      AdminOUIdentifier:
        Certificate: cacerts/ca-{{ .Values.metadata.namespace }}-7054.pem
        OrganizationalUnitIdentifier: admin
      OrdererOUIdentifier:
        Certificate: cacerts/ca-{{ .Values.metadata.namespace }}-7054.pem
        OrganizationalUnitIdentifier: orderer
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: tls-cert
  namespace: {{ .Values.metadata.namespace }}
  labels:
    app.kubernetes.io/name: tls-cert
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
data:
  {{- range $orderers := $.Values.orderers_info }}
  {{ $orderers.name }}.crt: |-
    {{ $.Files.Get $orderers.path | quote }}
  {{- end }}
